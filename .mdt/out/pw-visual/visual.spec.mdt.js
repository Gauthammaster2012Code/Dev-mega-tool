// GENERATED BY MDT â€” REVIEW
// scenario: visual
// generatedAt: 2025-08-23T16:47:00.432Z

import { firefox, chromium, webkit } from 'playwright-core';
import { PNG } from 'pngjs';
import pixelmatch from 'pixelmatch';
import { readFileSync, writeFileSync, existsSync, mkdirSync } from 'node:fs';
import { resolve } from 'node:path';

/**
 * Ensure a directory exists by creating it (including parent directories) if necessary.
 *
 * Attempts to create the directory at the given path using recursive creation. If creation fails,
 * the error is caught and a warning is logged; the function does not throw.
 *
 * @param {string} p - Path to the directory to ensure exists.
 */
function ensureDir(p) { try { mkdirSync(p, { recursive: true }); } catch (e) { console.warn('[MDT] ensureDir failed', e?.message || String(e)); }}

/**
 * Attempt to launch a Playwright browser from the available engines (firefox, chromium, webkit).
 * Tries each engine sequentially; if none succeed, waits with a small incremental backoff and repeats up to `retries` times.
 * @param {number} [retries=2] - Number of retry cycles after the initial attempt; each cycle tries all engines once.
 * @returns {Promise<import('playwright-core').Browser>} A browser instance from the first engine that launches successfully.
 * @throws {Error} The last error encountered if all launch attempts fail.
 */
async function launchWithRetry(retries = 2) {
	let last;
	for (let i = 0; i <= retries; i++) {
		for (const engine of [firefox, chromium, webkit]) {
			try {
				return await engine.launch();
			} catch (e) {
				last = e;
			}
		}
		await new Promise(r => setTimeout(r, 200 * (i + 1)));
	}
	throw last;
}

/**
 * Run a visual capture for a single device viewport and produce artifacts.
 *
 * Captures a full-page screenshot of `about:blank` using Playwright, writes the current screenshot to
 * .mdt/out/playwright-artifacts/visual.png, and:
 * - if no baseline exists, saves the current capture as visual.baseline.png;
 * - if a baseline exists, computes and writes a diff to visual.diff.png and logs the number of differing pixels.
 *
 * @param {string} name - Friendly name for the device run (used for logging/context only).
 * @param {import('playwright-core').ViewportSize & { deviceScaleFactor?: number, isMobile?: boolean, hasTouch?: boolean }} viewport - Viewport configuration to set on the page.
 * @returns {Promise<{ visual: null, skipped?: boolean }>} Resolves with an object containing `visual` (always null) and `skipped: true` when the run is skipped via the MDT_PW_SKIP environment variable.
 * @throws Will rethrow any error encountered while launching the browser, navigating, taking screenshots, or writing artifacts.
 */
async function runDevice(name, viewport) {
	if (process.env.MDT_PW_SKIP === '1') { return { visual: null, skipped: true }; }
	let browser;
	try {
		browser = await launchWithRetry(2);
		const page = await browser.newPage();
		await page.setViewportSize(viewport);
		for (const p of ["about:blank"]) { await page.goto(p, { waitUntil: 'networkidle' }); }
		
		let visual = null;
		const outDir = resolve(process.cwd(), '.mdt/out/playwright-artifacts');
	ensureDir(outDir);
	const currentPath = resolve(outDir, 'visual.png');
	const baselinePath = resolve(outDir, 'visual.baseline.png');
	const diffPath = resolve(outDir, 'visual.diff.png');
	const buffer = await page.screenshot({ fullPage: true });
	writeFileSync(currentPath, buffer);
	if (!existsSync(baselinePath)) { writeFileSync(baselinePath, buffer); }
	else {
		const baseline = PNG.sync.read(readFileSync(baselinePath));
		const current = PNG.sync.read(buffer);
		const width = Math.min(baseline.width, current.width);
		const height = Math.min(baseline.height, current.height);
		const diff = new PNG({ width, height });
		const diffPixels = pixelmatch(baseline.data, current.data, diff.data, width, height, { threshold: 0.1 });
		writeFileSync(diffPath, PNG.sync.write(diff));
		console.log('[MDT] visual diff', { diffPixels });
	}
	
		return { visual };
	} catch (err) {
		console.error('[MDT] runDevice failed', err && (err.stack || err.message || String(err)));
		throw err;
	} finally {
		if (browser) { try { await browser.close(); } catch (e) { console.warn('[MDT] close failed', e?.message || String(e)); } }
	}
}

describe('visual', () => {
	it('desktop', async () => {
		await runDevice('desktop', { width: 1366, height: 768, deviceScaleFactor: 1 });
	});
	it('mobile', async () => {
		await runDevice('mobile', { width: 390, height: 844, deviceScaleFactor: 2, isMobile: true, hasTouch: true });
	});
});

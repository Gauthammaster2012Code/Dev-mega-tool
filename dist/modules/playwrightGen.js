import { mkdir, writeFile } from "node:fs/promises";
import { resolve, basename } from "node:path";
import { createChildLogger } from "../shared/logger.js";
import { z } from "zod";
const stepSchema = z.object({
    type: z.enum(["click", "fill", "waitFor"]),
    selector: z.string().optional(),
    value: z.string().optional(),
    waitFor: z.string().optional(),
});
const scenarioSchema = z.object({
    name: z.string().regex(/^[a-zA-Z0-9_-]{1,64}$/),
    steps: z.array(stepSchema).max(200),
});
const paramsSchema = z.object({
    pages: z.array(z.string().url().or(z.literal("about:blank"))).min(1).max(50),
    scenarios: z.array(scenarioSchema).min(1).max(50),
    visualTesting: z.boolean().optional(),
    outputDir: z.string().optional(),
});
function escapeJsSingleQuoted(str) {
    return str
        .replace(/\\/g, "\\\\")
        .replace(/'/g, "\\'")
        .replace(/\r/g, "\\r")
        .replace(/\n/g, "\\n")
        .replace(/\t/g, "\\t");
}
async function writeFileWithRetry(path, content, tries = 3) {
    let lastErr;
    for (let i = 0; i < tries; i++) {
        try {
            await writeFile(path, content, "utf8");
            return;
        }
        catch (err) {
            lastErr = err;
            await new Promise((r) => setTimeout(r, 50 * (i + 1)));
        }
    }
    throw lastErr;
}
export class PlaywrightGenerator {
    repoRoot;
    log = createChildLogger("playwright-gen");
    constructor(repoRoot) {
        this.repoRoot = repoRoot;
    }
    async generate(params) {
        const parsed = paramsSchema.safeParse(params);
        if (!parsed.success) {
            this.log.warn({ issues: parsed.error.issues }, "Invalid Playwright generation parameters");
            throw Object.assign(new Error("Invalid Playwright parameters"), { code: "MDT_PLAYWRIGHT_INPUT_INVALID", details: parsed.error.issues });
        }
        const safe = parsed.data;
        const outDir = resolve(this.repoRoot, safe.outputDir || ".mdt/out/playwright");
        await mkdir(outDir, { recursive: true });
        const files = [];
        const template = this.buildTemplate(safe.visualTesting === true);
        for (const sc of safe.scenarios) {
            const safeName = sc.name; // already regex-validated
            const file = resolve(outDir, `${safeName}.spec.mdt.js`);
            const content = template(sc, safe.pages);
            await writeFileWithRetry(file, content, 3);
            files.push(file);
            this.log.info({ file }, "Generated Playwright test");
        }
        return { files };
    }
    buildTemplate(visual) {
        return (scenario, pages) => `// GENERATED BY MDT â€” REVIEW
// scenario: ${scenario.name}
// generatedAt: ${new Date().toISOString()}

import { firefox } from 'playwright-core';
import { PNG } from 'pngjs';
import pixelmatch from 'pixelmatch';
import { readFileSync, writeFileSync, existsSync, mkdirSync } from 'node:fs';
import { resolve } from 'node:path';

function ensureDir(p) { try { mkdirSync(p, { recursive: true }); } catch (e) { console.warn('[MDT] ensureDir failed', e?.message || String(e)); }}

async function launchWithRetry(retries = 2) {
	let last;
	for (let i = 0; i <= retries; i++) {
		try {
			return await firefox.launch();
		} catch (e) {
			last = e;
			await new Promise(r => setTimeout(r, 200 * (i + 1)));
		}
	}
	throw last;
}

async function runDevice(name, viewport) {
	if (process.env.MDT_PW_SKIP === '1') { return { visual: null, skipped: true }; }
	let browser;
	try {
		browser = await launchWithRetry(2);
		const page = await browser.newPage();
		await page.setViewportSize(viewport);
		for (const p of ${JSON.stringify(pages.map(p => p === "about:blank" ? p : p))}) { await page.goto(p, { waitUntil: 'networkidle' }); }
		${scenario.steps.map((s) => this.renderStep(s)).join("\n\t\t")}
		let visual = null;
		${visual ? this.renderVisualBlock(scenario.name) : ""}
		return { visual };
	} catch (err) {
		console.error('[MDT] runDevice failed', err && (err.stack || err.message || String(err)));
		throw err;
	} finally {
		if (browser) { try { await browser.close(); } catch (e) { console.warn('[MDT] close failed', e?.message || String(e)); } }
	}
}

describe('${scenario.name}', () => {
	it('desktop', async () => {
		await runDevice('desktop', { width: 1366, height: 768, deviceScaleFactor: 1 });
	});
	it('mobile', async () => {
		await runDevice('mobile', { width: 390, height: 844, deviceScaleFactor: 2, isMobile: true, hasTouch: true });
	});
});
`;
    }
    renderStep(step) {
        switch (step.type) {
            case "click": return `await page.click('${escapeJsSingleQuoted(step.selector || '')}');`;
            case "fill": return `await page.fill('${escapeJsSingleQuoted(step.selector || '')}', '${escapeJsSingleQuoted(step.value || '')}');`;
            case "waitFor": return `await page.waitForSelector('${escapeJsSingleQuoted(step.selector || step.waitFor || '')}');`;
            default: return `// unknown step`;
        }
    }
    renderVisualBlock(name) {
        const safe = basename(name).replace(/[^a-zA-Z0-9_-]/g, '-');
        return `const outDir = resolve(process.cwd(), '.mdt/out/playwright-artifacts');
	ensureDir(outDir);
	const currentPath = resolve(outDir, '${safe}.png');
	const baselinePath = resolve(outDir, '${safe}.baseline.png');
	const diffPath = resolve(outDir, '${safe}.diff.png');
	const buffer = await page.screenshot({ fullPage: true });
	writeFileSync(currentPath, buffer);
	if (!existsSync(baselinePath)) { writeFileSync(baselinePath, buffer); }
	else {
		const baseline = PNG.sync.read(readFileSync(baselinePath));
		const current = PNG.sync.read(buffer);
		const width = Math.min(baseline.width, current.width);
		const height = Math.min(baseline.height, current.height);
		const diff = new PNG({ width, height });
		const diffPixels = pixelmatch(baseline.data, current.data, diff.data, width, height, { threshold: 0.1 });
		writeFileSync(diffPath, PNG.sync.write(diff));
		console.log('[MDT] visual diff', { diffPixels });
	}
	`;
    }
}
//# sourceMappingURL=playwrightGen.js.map
import { mkdir, writeFile } from "node:fs/promises";
import { resolve } from "node:path";
import { createChildLogger } from "../shared/logger.js";
export class PuppeteerGenerator {
    repoRoot;
    log = createChildLogger("puppeteer-gen");
    constructor(repoRoot) {
        this.repoRoot = repoRoot;
    }
    async generate(params) {
        const outDir = resolve(this.repoRoot, params.outputDir || ".mdt/out/puppeteer");
        await mkdir(outDir, { recursive: true });
        const files = [];
        const template = this.buildTemplate(params.visualTesting === true);
        for (const sc of params.scenarios) {
            const file = resolve(outDir, `${sc.name}.spec.mdt.js`);
            const content = template(sc, params.pages);
            await writeFile(file, content, "utf8");
            files.push(file);
            this.log.info({ file }, "Generated Puppeteer test");
        }
        return { files };
    }
    buildTemplate(visual) {
        return (scenario, pages) => `// GENERATED BY MDT â€” REVIEW
// scenario: ${scenario.name}
// generatedAt: ${new Date().toISOString()}

import puppeteer from 'puppeteer-core';
import { PNG } from 'pngjs';
import pixelmatch from 'pixelmatch';
import { readFileSync, writeFileSync, existsSync, mkdirSync } from 'node:fs';
import { resolve, dirname } from 'node:path';

const CHROME_PATH = process.env.CHROME_PATH || process.env.PUPPETEER_EXECUTABLE_PATH || '';

function ensureDir(p) { try { mkdirSync(p, { recursive: true }); } catch {}}

async function runDevice(name, viewport) {
	if (!CHROME_PATH) { console.warn('[MDT] CHROME_PATH not set, skipping test'); return { skipped: true }; }
	const browser = await puppeteer.launch({ executablePath: CHROME_PATH, headless: 'new' });
	const page = await browser.newPage();
	await page.setViewport(viewport);
	for (const p of ${JSON.stringify(pages)}) { await page.goto(p, { waitUntil: 'networkidle0' }); }
	${scenario.steps.map((s) => this.renderStep(s)).join("\n\t")}
	let visual = null;
	${visual ? this.renderVisualBlock(scenario.name) : ""}
	await browser.close();
	return { skipped: false, visual };
}

describe('${scenario.name}', () => {
	it('desktop', async () => {
		await runDevice('desktop', { width: 1366, height: 768, deviceScaleFactor: 1 });
	});
	it('mobile', async () => {
		await runDevice('mobile', { width: 390, height: 844, deviceScaleFactor: 2, isMobile: true, hasTouch: true });
	});
});
`;
    }
    renderStep(step) {
        switch (step.type) {
            case "click": return `await page.click('${step.selector}');`;
            case "fill": return `await page.fill('${step.selector}', '${step.value || ""}');`;
            case "waitFor": return `await page.waitForSelector('${step.selector || step.waitFor}');`;
            default: return `// unknown step`;
        }
    }
    renderVisualBlock(name) {
        return `const outDir = resolve(process.cwd(), '.mdt/out/puppeteer-artifacts');
	ensureDir(outDir);
	const currentPath = resolve(outDir, '${name}.png');
	const baselinePath = resolve(outDir, '${name}.baseline.png');
	const diffPath = resolve(outDir, '${name}.diff.png');
	const buffer = await page.screenshot({ fullPage: true });
	writeFileSync(currentPath, buffer);
	if (!existsSync(baselinePath)) { writeFileSync(baselinePath, buffer); }
	else {
		const baseline = PNG.sync.read(readFileSync(baselinePath));
		const current = PNG.sync.read(buffer);
		const width = Math.min(baseline.width, current.width);
		const height = Math.min(baseline.height, current.height);
		const diff = new PNG({ width, height });
		const diffPixels = pixelmatch(baseline.data, current.data, diff.data, width, height, { threshold: 0.1 });
		writeFileSync(diffPath, PNG.sync.write(diff));
		console.log('[MDT] visual diff', { diffPixels });
	}
	`;
    }
}
//# sourceMappingURL=puppeteerGen.js.map
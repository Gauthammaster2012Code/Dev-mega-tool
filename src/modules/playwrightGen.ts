import { mkdir, writeFile } from "node:fs/promises";
import { resolve, basename } from "node:path";
import { createChildLogger } from "../shared/logger.js";
import { z } from "zod";

export type StepType = "click" | "fill" | "waitFor";
export interface PWScenarioStep { type: StepType; selector?: string; value?: string; waitFor?: string; }
export interface PWScenario { name: string; steps: PWScenarioStep[] }

export interface GeneratePlaywrightParams {
	pages: string[];
	scenarios: PWScenario[];
	visualTesting?: boolean;
	outputDir?: string; // default .mdt/out/playwright
}

const stepSchema = z.object({
	type: z.enum(["click", "fill", "waitFor"]),
	selector: z.string().optional(),
	value: z.string().optional(),
	waitFor: z.string().optional(),
});

const scenarioSchema = z.object({
	name: z.string().regex(/^[a-zA-Z0-9_-]{1,64}$/),
	steps: z.array(stepSchema).max(200),
});

const paramsSchema = z.object({
	pages: z.array(z.string().url().or(z.literal("about:blank"))).min(1).max(50),
	scenarios: z.array(scenarioSchema).min(1).max(50),
	visualTesting: z.boolean().optional(),
	outputDir: z.string().optional(),
});

function escapeJsSingleQuoted(str: string): string {
	return str
		.replace(/\\/g, "\\\\")
		.replace(/'/g, "\\'")
		.replace(/\r/g, "\\r")
		.replace(/\n/g, "\\n")
		.replace(/\t/g, "\\t");
}

async function writeFileWithRetry(path: string, content: string, tries = 3): Promise<void> {
	let lastErr: any;
	for (let i = 0; i < tries; i++) {
		try {
			await writeFile(path, content, "utf8");
			return;
		} catch (err: any) {
			lastErr = err;
			await new Promise((r) => setTimeout(r, 50 * (i + 1)));
		}
	}
	throw lastErr;
}

export class PlaywrightGenerator {
	private readonly log = createChildLogger("playwright-gen");
	constructor(private readonly repoRoot: string) {}

	async generate(params: GeneratePlaywrightParams): Promise<{ files: string[] }> {
		const parsed = paramsSchema.safeParse(params);
		if (!parsed.success) {
			this.log.warn({ issues: parsed.error.issues }, "Invalid Playwright generation parameters");
			throw Object.assign(new Error("Invalid Playwright parameters"), { code: "MDT_PLAYWRIGHT_INPUT_INVALID", details: parsed.error.issues });
		}
		const safe = parsed.data;
		const outDir = resolve(this.repoRoot, safe.outputDir || ".mdt/out/playwright");
		await mkdir(outDir, { recursive: true });
		const files: string[] = [];
		const template = this.buildTemplate(safe.visualTesting === true);
		for (const sc of safe.scenarios) {
			const safeName = sc.name; // already regex-validated
			const file = resolve(outDir, `${safeName}.spec.mdt.js`);
			const content = template(sc, safe.pages);
			await writeFileWithRetry(file, content, 3);
			files.push(file);
			this.log.info({ file }, "Generated Playwright test");
		}
		return { files };
	}

	private buildTemplate(visual: boolean) {
		return (scenario: PWScenario, pages: string[]) => `// GENERATED BY MDT â€” REVIEW
// scenario: ${scenario.name}
// generatedAt: ${new Date().toISOString()}

import { firefox, chromium, webkit } from 'playwright-core';
import { PNG } from 'pngjs';
import pixelmatch from 'pixelmatch';
import { readFileSync, writeFileSync, existsSync, mkdirSync } from 'node:fs';
import { resolve } from 'node:path';

function ensureDir(p) { try { mkdirSync(p, { recursive: true }); } catch (e) { console.warn('[MDT] ensureDir failed', e?.message || String(e)); }}

async function launchWithRetry(retries = 2) {
	let last;
	for (let i = 0; i <= retries; i++) {
		for (const engine of [firefox, chromium, webkit]) {
			try {
				return await engine.launch();
			} catch (e) {
				last = e;
			}
		}
		await new Promise(r => setTimeout(r, 200 * (i + 1)));
	}
	throw last;
}

async function runDevice(name, viewport) {
	if (process.env.MDT_PW_SKIP === '1') { return { visual: null, skipped: true }; }
	let browser;
	try {
		browser = await launchWithRetry(2);
		const page = await browser.newPage();
		await page.setViewportSize(viewport);
		for (const p of ${JSON.stringify(pages.map(p => p === "about:blank" ? p : p))}) { await page.goto(p, { waitUntil: 'networkidle' }); }
		${scenario.steps.map((s) => this.renderStep(s)).join("\n\t\t")}
		let visual = null;
		${visual ? this.renderVisualBlock(scenario.name) : ""}
		return { visual };
	} catch (err) {
		console.error('[MDT] runDevice failed', err && (err.stack || err.message || String(err)));
		throw err;
	} finally {
		if (browser) { try { await browser.close(); } catch (e) { console.warn('[MDT] close failed', e?.message || String(e)); } }
	}
}

describe('${escapeJsSingleQuoted(scenario.name)}', () => {
	it('desktop', async () => {
		await runDevice('desktop', { width: 1366, height: 768, deviceScaleFactor: 1 });
	});
	it('mobile', async () => {
		await runDevice('mobile', { width: 390, height: 844, deviceScaleFactor: 2, isMobile: true, hasTouch: true });
	});
});
`;
	}

	private renderStep(step: PWScenarioStep): string {
		switch (step.type) {
			case "click": return `await page.click('${escapeJsSingleQuoted(step.selector || '')}');`;
			case "fill": return `await page.fill('${escapeJsSingleQuoted(step.selector || '')}', '${escapeJsSingleQuoted(step.value || '')}');`;
			case "waitFor": return `await page.waitForSelector('${escapeJsSingleQuoted(step.selector || step.waitFor || '')}');`;
			default: return `// unknown step`;
		}
	}

	private renderVisualBlock(name: string): string {
		const safe = basename(name).replace(/[^a-zA-Z0-9_-]/g, '-');
		return `const outDir = resolve(process.cwd(), '.mdt/out/playwright-artifacts');
	ensureDir(outDir);
	const currentPath = resolve(outDir, '${safe}.png');
	const baselinePath = resolve(outDir, '${safe}.baseline.png');
	const diffPath = resolve(outDir, '${safe}.diff.png');
	const buffer = await page.screenshot({ fullPage: true });
	writeFileSync(currentPath, buffer);
	if (!existsSync(baselinePath)) { writeFileSync(baselinePath, buffer); }
	else {
		const baseline = PNG.sync.read(readFileSync(baselinePath));
		const current = PNG.sync.read(buffer);
		const width = Math.min(baseline.width, current.width);
		const height = Math.min(baseline.height, current.height);
		const diff = new PNG({ width, height });
		const diffPixels = pixelmatch(baseline.data, current.data, diff.data, width, height, { threshold: 0.1 });
		writeFileSync(diffPath, PNG.sync.write(diff));
		console.log('[MDT] visual diff', { diffPixels });
	}
	`;
	}
}
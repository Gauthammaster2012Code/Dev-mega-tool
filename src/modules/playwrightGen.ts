import { mkdir, writeFile } from "node:fs/promises";
import { resolve } from "node:path";
import { createChildLogger } from "../shared/logger.js";

export interface PWScenarioStep { type: string; selector?: string; value?: string; waitFor?: string; }
export interface PWScenario { name: string; steps: PWScenarioStep[] }

export interface GeneratePlaywrightParams {
	pages: string[];
	scenarios: PWScenario[];
	visualTesting?: boolean;
	outputDir?: string; // default .mdt/out/playwright
}

export class PlaywrightGenerator {
	private readonly log = createChildLogger("playwright-gen");
	constructor(private readonly repoRoot: string) {}

	async generate(params: GeneratePlaywrightParams): Promise<{ files: string[] }> {
		const outDir = resolve(this.repoRoot, params.outputDir || ".mdt/out/playwright");
		await mkdir(outDir, { recursive: true });
		const files: string[] = [];
		const template = this.buildTemplate(params.visualTesting === true);
		for (const sc of params.scenarios) {
			const file = resolve(outDir, `${sc.name}.spec.mdt.js`);
			const content = template(sc, params.pages);
			await writeFile(file, content, "utf8");
			files.push(file);
			this.log.info({ file }, "Generated Playwright test");
		}
		return { files };
	}

	private buildTemplate(visual: boolean) {
		return (scenario: PWScenario, pages: string[]) => `// GENERATED BY MDT â€” REVIEW
// scenario: ${scenario.name}
// generatedAt: ${new Date().toISOString()}

import { firefox } from 'playwright-core';
import { PNG } from 'pngjs';
import pixelmatch from 'pixelmatch';
import { readFileSync, writeFileSync, existsSync, mkdirSync } from 'node:fs';
import { resolve, dirname } from 'node:path';

function ensureDir(p) { try { mkdirSync(p, { recursive: true }); } catch {}}

async function runDevice(name, viewport) {
	const browser = await firefox.launch();
	const page = await browser.newPage();
	await page.setViewportSize(viewport);
	for (const p of ${JSON.stringify(pages)}) { await page.goto(p, { waitUntil: 'networkidle' }); }
	${scenario.steps.map((s) => this.renderStep(s)).join("\n\t")}
	let visual = null;
	${visual ? this.renderVisualBlock(scenario.name) : ""}
	await browser.close();
	return { visual };
}

describe('${scenario.name}', () => {
	it('desktop', async () => {
		await runDevice('desktop', { width: 1366, height: 768, deviceScaleFactor: 1 });
	});
	it('mobile', async () => {
		await runDevice('mobile', { width: 390, height: 844, deviceScaleFactor: 2, isMobile: true, hasTouch: true });
	});
});
`;
	}

	private renderStep(step: PWScenarioStep): string {
		switch (step.type) {
			case "click": return `await page.click('${step.selector}');`;
			case "fill": return `await page.fill('${step.selector}', '${step.value || ""}');`;
			case "waitFor": return `await page.waitForSelector('${step.selector || step.waitFor}');`;
			default: return `// unknown step`;
		}
	}

	private renderVisualBlock(name: string): string {
		return `const outDir = resolve(process.cwd(), '.mdt/out/playwright-artifacts');
	ensureDir(outDir);
	const currentPath = resolve(outDir, '${name}.png');
	const baselinePath = resolve(outDir, '${name}.baseline.png');
	const diffPath = resolve(outDir, '${name}.diff.png');
	const buffer = await page.screenshot({ fullPage: true });
	writeFileSync(currentPath, buffer);
	if (!existsSync(baselinePath)) { writeFileSync(baselinePath, buffer); }
	else {
		const baseline = PNG.sync.read(readFileSync(baselinePath));
		const current = PNG.sync.read(buffer);
		const width = Math.min(baseline.width, current.width);
		const height = Math.min(baseline.height, current.height);
		const diff = new PNG({ width, height });
		const diffPixels = pixelmatch(baseline.data, current.data, diff.data, width, height, { threshold: 0.1 });
		writeFileSync(diffPath, PNG.sync.write(diff));
		console.log('[MDT] visual diff', { diffPixels });
	}
	`;
	}
}
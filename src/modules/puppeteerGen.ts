import { mkdir, writeFile } from "node:fs/promises";
import { resolve, basename } from "node:path";
import { createChildLogger } from "../shared/logger.js";
import { z } from "zod";

export type StepType = "click" | "fill" | "waitFor";
export interface ScenarioStep { type: StepType; selector?: string; value?: string; waitFor?: string; }
export interface Scenario { name: string; steps: ScenarioStep[] }

export interface GeneratePuppeteerParams {
	pages: string[];
	scenarios: Scenario[];
	visualTesting?: boolean;
	outputDir?: string; // default .mdt/out/puppeteer
}

const stepSchema = z.object({
	type: z.enum(["click", "fill", "waitFor"] as const),
	selector: z.string().optional(),
	value: z.string().optional(),
	waitFor: z.string().optional(),
});
const scenarioSchema = z.object({ name: z.string().regex(/^[a-zA-Z0-9_-]{1,64}$/), steps: z.array(stepSchema).max(200) });
const paramsSchema = z.object({ pages: z.array(z.string()).min(1).max(50), scenarios: z.array(scenarioSchema).min(1).max(50), visualTesting: z.boolean().optional(), outputDir: z.string().optional() });

function escapeJsSingleQuoted(str: string): string { return str.replace(/\\/g, "\\\\").replace(/'/g, "\\'").replace(/\r/g, "\\r").replace(/\n/g, "\\n").replace(/\t/g, "\\t"); }

type ZScenario = z.infer<typeof scenarioSchema>;

export class PuppeteerGenerator {
	private readonly log = createChildLogger("puppeteer-gen");
	constructor(private readonly repoRoot: string) {}

	async generate(params: GeneratePuppeteerParams): Promise<{ files: string[] }> {
		const parsed = paramsSchema.safeParse(params);
		if (!parsed.success) {
			throw Object.assign(new Error("Invalid Puppeteer parameters"), { code: "MDT_PUPPETEER_INPUT_INVALID", details: parsed.error.issues });
		}
		const safe = parsed.data;
		const outDir = resolve(this.repoRoot, safe.outputDir || ".mdt/out/puppeteer");
		await mkdir(outDir, { recursive: true });
		const files: string[] = [];
		const template = this.buildTemplate(safe.visualTesting === true);
		for (const sc of safe.scenarios) {
			const file = resolve(outDir, `${sc.name}.spec.mdt.js`);
			const content = template(sc, safe.pages);
			await writeFile(file, content, "utf8");
			files.push(file);
			this.log.info({ file }, "Generated Puppeteer test");
		}
		return { files };
	}

	private buildTemplate(visual: boolean) {
		return (scenario: ZScenario, pages: string[]) => `// GENERATED BY MDT â€” REVIEW
// scenario: ${scenario.name}
// generatedAt: ${new Date().toISOString()}

import puppeteer from 'puppeteer-core';
import { PNG } from 'pngjs';
import pixelmatch from 'pixelmatch';
import { readFileSync, writeFileSync, existsSync, mkdirSync } from 'node:fs';
import { resolve, dirname } from 'node:path';

const CHROME_PATH = process.env.CHROME_PATH || process.env.PUPPETEER_EXECUTABLE_PATH || '';

function ensureDir(p) { try { mkdirSync(p, { recursive: true }); } catch {}}

async function runDevice(name, viewport) {
	if (!CHROME_PATH) { console.warn('[MDT] CHROME_PATH not set, skipping test'); return { skipped: true }; }
	const browser = await puppeteer.launch({ executablePath: CHROME_PATH, headless: 'new' });
	try {
		const page = await browser.newPage();
		await page.setViewport(viewport);
		for (const p of ${JSON.stringify(pages)}) { await page.goto(p, { waitUntil: 'networkidle0' }); }
		${scenario.steps.map((s) => this.renderStep(s as any)).join("\n\t")}
		let visual = null;
		${visual ? this.renderVisualBlock(scenario.name) : ""}
		return { skipped: false, visual };
	} finally {
		try { await browser.close(); } catch {}
	}
}

describe('${escapeJsSingleQuoted(scenario.name)}', () => {
	it('desktop', async () => {
		await runDevice('desktop', { width: 1366, height: 768, deviceScaleFactor: 1 });
	});
	it('mobile', async () => {
		await runDevice('mobile', { width: 390, height: 844, deviceScaleFactor: 2, isMobile: true, hasTouch: true });
	});
});
`;
	}

	private renderStep(step: ScenarioStep): string {
		switch (step.type) {
			case "click": return `await page.click('${escapeJsSingleQuoted(step.selector || '')}');`;
			case "fill": return `await page.fill('${escapeJsSingleQuoted(step.selector || '')}', '${escapeJsSingleQuoted(step.value || '')}');`;
			case "waitFor": return `await page.waitForSelector('${escapeJsSingleQuoted(step.selector || step.waitFor || '')}');`;
			default: return `// unknown step`;
		}
	}

	private renderVisualBlock(name: string): string {
		const safe = basename(name).replace(/[^a-zA-Z0-9_-]/g, '-');
		return `const outDir = resolve(process.cwd(), '.mdt/out/puppeteer-artifacts');
	ensureDir(outDir);
	const currentPath = resolve(outDir, '${safe}.png');
	const baselinePath = resolve(outDir, '${safe}.baseline.png');
	const diffPath = resolve(outDir, '${safe}.diff.png');
	const buffer = await page.screenshot({ fullPage: true });
	writeFileSync(currentPath, buffer);
	if (!existsSync(baselinePath)) { writeFileSync(baselinePath, buffer); }
	else {
		const baseline = PNG.sync.read(readFileSync(baselinePath));
		const current = PNG.sync.read(buffer);
		const width = Math.min(baseline.width, current.width);
		const height = Math.min(baseline.height, current.height);
		const diff = new PNG({ width, height });
		const diffPixels = pixelmatch(baseline.data, current.data, diff.data, width, height, { threshold: 0.1 });
		writeFileSync(diffPath, PNG.sync.write(diff));
		console.log('[MDT] visual diff', { diffPixels });
	}
	`;
	}
}